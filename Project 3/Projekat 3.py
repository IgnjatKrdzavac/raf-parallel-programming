# -*- coding: utf-8 -*-
"""Ignjat_Krdzavac_115.20.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1K7TMYD2s_fQ5D0_JfbjxU6gh0MjgJ2m4
"""

!pip install pycuda

!nvidia-smi

"""#Stavka 1"""

import pycuda.driver as cuda
import pycuda.autoinit
from pycuda.compiler import SourceModule
import math
import numpy as np

#gemm(transa, transb, m, n, k, alpha, A, B): 
     #alpha * (opA(A) X opB(B))

mod = SourceModule("""
     __global__ void gemm(int transa, int transb, int visinaA, int sirinaA, int missingB, int alpha, float *a, float *b, float *c, float *zbir)
     {      
            
            

            int idx = threadIdx.x + threadIdx.y*missingB;
            int indeksA;
            int indeksB;
            int indexZbira = 0;
            int tmp;

            if(transa == 1){
               tmp = visinaA;
               visinaA = sirinaA;
               sirinaA = tmp;
            }
           

            

            for(int i = 0; i < visinaA; i++){

                if(transa){indeksA = i;}
                
                else{indeksA = i * sirinaA;}
                
                indeksB = 0;

                for(int k = 0; k < missingB; k++){

                    for(int j = 0; j < sirinaA;j++){

                      if(transa){
                            zbir[indexZbira] += a[indeksA + j*visinaA] * b[indeksB];
                        }
                        else{
                            zbir[indexZbira] += a[indeksA + j]*b[indeksB];
                        }


                      if(transb){
                          indeksB += 1;
                      }  
                      else{
                          indeksB += missingB;
                      }
                    }
                    zbir[indexZbira] = zbir[indexZbira] * alpha;

                    if(transb == 0){indeksB = k + 1;}
                    indexZbira++;
                }
                 
                 c[idx] = zbir[idx];
                    
            }

      }
            
   """)


visinaA = int(input("Unesite broj redova matrice A: "))
sirinaA = int(input("Unesite broj kolona matrice A: "))

visinaB = int(input("Unesite broj redova matrice B: "))
sirinaB = int(input("Unesite broj kolona matrice B: "))

transa = int(input("Unesite transA(0 za ne, 1 za da): "))
transb = int(input("Unesite transB(0 za ne, 1 za da): "))



if(sirinaA != visinaB and (transa + transb == 0)):
    print("Los unos, nemoguce je pomnoziti ove matrice")

elif(transa == 1 and transb == 0 and (visinaA != visinaB)):
    print("Los unos, nemoguce je pomnoziti ove matrice")

elif(transa == 0 and transb == 1 and (sirinaA != sirinaB)):
    print("Los unos, nemoguce je pomnoziti ove matrice")    

elif(transa == 1 and transb == 1 and (visinaA != sirinaB)):
    print("Los unos, nemoguce je pomnoziti ove matrice")   

else:
    alpha = float(input("Unesite skalarnu vrednost kojom cemo pomnoziti rezultujucu matricu: "))
    
    a = np.random.randn(visinaA,sirinaA).astype(dtype=np.float32)
    b = np.random.randn(visinaB,sirinaB).astype(dtype=np.float32)

    if(sirinaA == visinaB and (transa + transb == 0)):
        visinaC = visinaA
        sirinaC = sirinaB
        missing = sirinaB

    elif(transa == 0 and transb == 1 and (sirinaA == sirinaB)):
        visinaC = visinaA
        sirinaC = visinaB
        missing = visinaB

    elif(transa == 1 and transb == 0 and (visinaA == visinaB)):
        visinaC = sirinaA
        sirinaC = sirinaB
        missing = sirinaB

    elif(transa == 1 and transb == 1 and (visinaA == sirinaB)):
        visinaC = sirinaA
        sirinaC = visinaB   
        missing = visinaB     

    c = np.zeros((visinaC,sirinaC)).astype(dtype=np.float32)
    zbir = np.zeros((visinaC,sirinaC)).astype(dtype=np.float32)
    a = np.round(a, 1)
    b = np.round(b, 1)

    print("Originalna matrica C:\n", c)
    print("Originalna matrica A:\n", a)
    print("Originalna matrica B:\n", b)

    a_gpu = cuda.mem_alloc(a.nbytes)  
    cuda.memcpy_htod(a_gpu, a)

    b_gpu = cuda.mem_alloc(b.nbytes)  
    cuda.memcpy_htod(b_gpu, b)

    c_gpu = cuda.mem_alloc(c.nbytes)  
    cuda.memcpy_htod(c_gpu, c) 

    zbir_gpu = cuda.mem_alloc(zbir.nbytes)  
    cuda.memcpy_htod(zbir_gpu, zbir)

    func = mod.get_function("gemm")

    paran = 0
    func(np.int32(transa),np.int32(transb),np.int32(visinaA),np.int32(sirinaA),np.int32(missing),np.int32(alpha),a_gpu, b_gpu, c_gpu, zbir_gpu,block=(sirinaC,visinaC,1), grid=(1, 1, 1))

    cuda.memcpy_dtoh(c, c_gpu)
    c = np.round(c, 1)

    print("Rezultujuca matrica C:\n", c)

"""#Stavka 2"""

import pycuda.driver as cuda
import pycuda.autoinit
from pycuda.compiler import SourceModule
import math
import numpy as np


mod = SourceModule("""
     __global__ void gemm(float *a, float *b, float *c, float *zbir, int visinaA, int sirinaA, int missingB, int alpha,int transa,int transb)
     {
       int x = threadIdx.x + blockDim.x*blockIdx.x;
       int y = threadIdx.y + blockDim.y*blockIdx.y;
       long idx = int(x + y*missingB);

      int indeksA;
      int indeksB;
      long indexZbira = 0;

      int tmp;

      if(transa == 1){
            tmp = visinaA;
            visinaA = sirinaA;
            sirinaA = tmp;
        }

      
      for(int i = 0; i < visinaA; i++){

          if(transa){indeksA = i;}
                
          else{indeksA = i * sirinaA;}
          
          indeksB = 0;

          for(int k = 0; k < missingB; k++){

              for(int j = 0; j < sirinaA;j++){

               
                  if(transa){
                            zbir[indexZbira] += a[indeksA + j*visinaA] * b[indeksB];
                        }
                  else{
                            zbir[indexZbira] += a[indeksA + j]*b[indeksB];
                       }


                  if(transb){
                        indeksB += 1;
                   }  
                  else{
                        indeksB += missingB;
                   }
                
              }
              if(idx == indexZbira)
                c[idx] =zbir[idx] * alpha;
              if(transb == 0){indeksB = k + 1;}
              indexZbira++;
          }
             
      }

        
     }
   """)


visinaA = int(input("Unesite broj redova matrice A: "))
sirinaA = int(input("Unesite broj kolona matrice A: "))

visinaB = int(input("Unesite broj redova matrice B: "))
sirinaB = int(input("Unesite broj kolona matrice B: "))

transa = int(input("Unesite transA(0 za ne, 1 za da): "))
transb = int(input("Unesite transB(0 za ne, 1 za da): "))



if(sirinaA != visinaB and (transa + transb == 0)):
    print("Los unos, nemoguce je pomnoziti ove matrice")

elif(transa == 1 and transb == 0 and (visinaA != visinaB)):
    print("Los unos, nemoguce je pomnoziti ove matrice")

elif(transa == 0 and transb == 1 and (sirinaA != sirinaB)):
    print("Los unos, nemoguce je pomnoziti ove matrice")    

elif(transa == 1 and transb == 1 and (visinaA != sirinaB)):
    print("Los unos, nemoguce je pomnoziti ove matrice") 


else:
    alpha = float(input("Unesite skalarnu vrednost kojom cemo pomnoziti rezultujucu matricu: "))
    
    a = np.random.randn(visinaA,sirinaA).astype(dtype=np.float32)
    b = np.random.randn(visinaB,sirinaB).astype(dtype=np.float32)

    if(sirinaA == visinaB and (transa + transb == 0)):
        visinaC = visinaA
        sirinaC = sirinaB
        missing = sirinaB

    elif(transa == 0 and transb == 1 and (sirinaA == sirinaB)):
        visinaC = visinaA
        sirinaC = visinaB
        missing = visinaB

    elif(transa == 1 and transb == 0 and (visinaA == visinaB)):
        visinaC = sirinaA
        sirinaC = sirinaB
        missing = sirinaB

    elif(transa == 1 and transb == 1 and (visinaA == sirinaB)):
        visinaC = sirinaA
        sirinaC = visinaB   
        missing = visinaB     

    c = np.zeros((visinaC,sirinaC)).astype(dtype=np.float32)
    zbir = np.zeros((visinaC,sirinaC)).astype(dtype=np.float32)
    a = np.round(a, 1)
    b = np.round(b, 1)

    print("Originalna matrica C:\n", c)
    print("Originalna matrica A:\n", a)
    print("Originalna matrica B:\n", b)

    a_gpu = cuda.mem_alloc(a.nbytes)  
    cuda.memcpy_htod(a_gpu, a)

    b_gpu = cuda.mem_alloc(b.nbytes)  
    cuda.memcpy_htod(b_gpu, b)

    c_gpu = cuda.mem_alloc(c.nbytes)  
    cuda.memcpy_htod(c_gpu, c) 

    zbir_gpu = cuda.mem_alloc(zbir.nbytes)  
    cuda.memcpy_htod(zbir_gpu, zbir)

    func = mod.get_function("gemm")

    func(a_gpu, b_gpu, c_gpu, zbir_gpu ,np.int32(visinaA), np.int32(sirinaA), np.int32(missing),np.int32(alpha),np.int32(transa),np.int32(transb),
         block=(32, 32, 1), grid=(math.ceil(c.shape[1]/32), math.ceil(c.shape[0]/32), 1)) 

    cuda.memcpy_dtoh(c, c_gpu)  # kopiranje Device TO Host
    c = np.round(c, 1)

    print("Rezultujuca matrica C:\n", c)